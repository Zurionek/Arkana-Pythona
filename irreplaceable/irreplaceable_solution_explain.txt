Opis rozwiązania zadania

Kod zadania Irreplaceable składa się w zasadzie z trzech części:
1. Zestawu funkcji mix_*, które wykonują proste odwracalne transformacje na podanej
tablicy bajtów i które stanowią podstawowy element budulcowy dla funkcji
transform_*.
2. Zestawu Funkcje transform_*, które używają 5 wybranych podstawowych transformacji
(mix_*) na podanym ciągu bajtów.
3. Oraz delikatnie ukrytego kodu, który modyfikuje to które faktycznie funkcje mix_* są
wywoływane w funkcjach transform_*.

Warto zacząć od analizy ukrytego kod – widocznego od razu jeśli nasz edytor ma włączony "word
wrapping" (w innym wypadku trzeba zauważyć np. brak dwukropka w nagłówku funkcji main):

def main()
-> any(globals().__setitem__(k,
type(mix_ror)(v.__code__.replace(co_names=v.__code__.co_names[::-1]),
globals(), k)) for k, v in dict(globals()).items() if
zlib.crc32(k[:-1].encode()) == 2177289788): # Nothing to see here, move
along.

Przepisując kod na trochę czytelniejszy pseudokod otrzymujemy:
1. Dla wszystkich funkcji zadeklarowanych w przestrzenii globalnej, kórych nazwa bez
ostatniego znaku ma CRC32 równe 2177289788:
a. Podmień tę funkcję na identyczną funkcją, z zapisaną od tyłu tablicą co_names
(odwołania do nazw globalnych).
Ustalenie które funkcje mają odpowiednie CRC32(nazwa_bez_ostatniego_znaku) jest bardzo
proste – nie ma w końcu zbyt wielu możliwości:

>>> import zlib
>>> zlib.crc32(b"mix_")
3007102966
>>> zlib.crc32(b"transform_")
2177289788

Warto w tym momencie popatrzeć na tablicę co_names obiektu code jednej z tych funkcji i
pomyśleć jak "przepisanie tej tablicy na wspak" zmieni działanie tej funkcji.
Przykładowo, transform_0 wygląda następująco:
def transform_0(b):
mix_xor(b) or mix_add(b) or mix_add(b) or mix_sub(b) or mix_ror(b)
>>> transform_0.__code__.co_names
('mix_xor', 'mix_add', 'mix_sub', 'mix_ror')
>>> transform_0.__code__.co_names[::-1]
('mix_ror', 'mix_sub', 'mix_add', 'mix_xor')
Co za tym idzie, po modyfikacji wywołanie
● mix_xor zmienia się na mix_ror,
● mix_add na mix_sub,
● mix_sub na mix_add,
● i mix_ror na mix_xor.

Pierwszym krokiem będzie zatem przepisanie wszystkich funkcji transform_* na ich
zmodyfikowaną postać.

Teraz możemy usunąć "ukryty" kod i przeanalizować pozostałe zadanie, które, zwyczajowo ma
postać enc(input) == flagenc
Co za tym idzie, naszym celem będzie wykonanie odwrotnych operacji.
W odwrotnej kolejności aby zdekodować flagę z jej posiadanej wersji zakodowanej (flagenc, tj.b'K\xe4\xf9...').

Zacznijmy od przepisania funkcji mix_* na ich odwrotne ekwiwalenty, tj. zamienimy dodawanie
na odejmowanie, obrót bitowy w prawo na obrót bitory w lewo, i tak dalej (w zasadzie wystarczy
zmienić 4 znaki zaznaczone poniżej) - /sprawdz w prezentacji jak to wygląda na kodzie/

Drugim krokiem będzie odwrócenie zmodyfikowanych funkcji transform_*, czyli po prostu
wywołanie "poprawionych" funkcji mix_*, ale w odwrotnej kolejności /sprawdz w prezentacji jak to wygląda na kodzie/

I na samym końcu wystarczy odwrócić kolejność wywołań samych funkcji transform_* w funkcji
main() i wywołać je na posiadanej zakodowanej fladze.

def main():
b = bytearray(b'K\xe4\xf9\xb1Nhn\x82\xbd\xa4\x88\x99\xa4n\xb1\xa8d\xe7D\xc7\xe4\xebd\xf9BD\x8e')
transform_4(b)
transform_3(b)
transform_2(b)
transform_1(b)
transform_0(b)
print(b)
if __name__ == "__main__":
main()

Po uruchomieniu tak przygotowanego kodu otrzymamy flagę!
